"""
OSF-Energy - Energy Asset Management AI
Solar, wind, battery, and grid management

This module extends OSF Core with energy-specific capabilities:
- Production monitoring and anomaly detection
- Performance optimization recommendations
- Carbon credit calculation
- Grid integration management
"""

import json
from dataclasses import dataclass
from typing import Optional
from datetime import datetime

from google import genai
from google.genai import types
import structlog

from src.config import get_settings
from src.ai.core import OSFCore, AssetClass

logger = structlog.get_logger()
settings = get_settings()


@dataclass
class EnergyAsset:
    """An energy asset in the OSF network."""
    id: str
    asset_type: str  # solar, wind, battery, ev_charger
    capacity_kw: float
    location: str
    installation_date: datetime
    status: str  # online, offline, maintenance, fault


@dataclass
class ProductionAnalysis:
    """AI analysis of energy production."""
    current_output_kw: float
    expected_output_kw: float
    efficiency_percent: float
    status: str  # optimal, degraded, fault
    diagnosis: str
    recommendations: list[str]
    estimated_daily_production_kwh: float
    carbon_offset_kg: float


@dataclass
class PerformanceAlert:
    """An alert generated by performance monitoring."""
    severity: str  # critical, warning, info
    alert_type: str
    message: str
    asset_id: str
    recommended_action: str
    estimated_revenue_impact: Optional[float] = None


class EnergyManager:
    """
    OSF Energy Manager - Specialized AI for energy assets.
    
    Extends OSF Core with:
    - Production monitoring and forecasting
    - Performance optimization
    - Grid integration management
    - Carbon credit tracking
    - Maintenance prediction
    """
    
    PERFORMANCE_ANALYSIS_PROMPT = """Analyze this energy system performance data.

SYSTEM INFO:
{system_info}

CURRENT READINGS:
{readings}

WEATHER CONDITIONS:
{weather}

Analyze the performance and respond in JSON:
{{
    "current_output_kw": number,
    "expected_output_kw": number (based on conditions),
    "efficiency_percent": number (current/expected * 100),
    "status": "optimal|degraded|fault",
    "diagnosis": "explanation of current performance",
    "recommendations": ["list", "of", "recommendations"],
    "estimated_daily_production_kwh": number,
    "carbon_offset_kg": number (using 0.4 kg CO2/kWh)
}}

Consider:
- Weather impact on production
- Time of day and sun angle
- System age and expected degradation
- Historical performance patterns
"""

    ALERT_GENERATION_PROMPT = """Based on this energy system data, generate any necessary alerts.

SYSTEM INFO:
{system_info}

CURRENT STATE:
{current_state}

THRESHOLDS:
- Critical: Production <20% of expected
- Warning: Production <60% of expected  
- Info: Minor optimization opportunities

Generate alerts in JSON array format:
[
    {{
        "severity": "critical|warning|info",
        "alert_type": "production|equipment|grid|safety",
        "message": "Clear description of the issue",
        "recommended_action": "What to do",
        "estimated_revenue_impact": number or null
    }}
]

Return empty array [] if no alerts needed.
"""

    def __init__(self):
        """Initialize Energy Manager."""
        self.core = OSFCore()
        if settings.google_api_key:
            self.client = genai.Client(api_key=settings.google_api_key)
            self.model_name = settings.gemini_model
        else:
            self.client = None
            self.model_name = None

    async def analyze_production(
        self,
        system_info: dict,
        readings: dict,
        weather: dict = None,
    ) -> ProductionAnalysis:
        """
        Analyze current production against expectations.
        
        Args:
            system_info: System specs (capacity, type, age, etc.)
            readings: Current sensor readings (output, voltage, etc.)
            weather: Current weather conditions
            
        Returns:
            ProductionAnalysis with status and recommendations
        """
        if not self.client:
            return ProductionAnalysis(
                current_output_kw=readings.get("output_kw", 0),
                expected_output_kw=0,
                efficiency_percent=0,
                status="unknown",
                diagnosis="AI analysis unavailable",
                recommendations=["Contact support"],
                estimated_daily_production_kwh=0,
                carbon_offset_kg=0,
            )
        
        prompt = self.PERFORMANCE_ANALYSIS_PROMPT.format(
            system_info=json.dumps(system_info, indent=2),
            readings=json.dumps(readings, indent=2),
            weather=json.dumps(weather, indent=2) if weather else "No weather data",
        )
        
        try:
            response = await self.client.aio.models.generate_content(
                model=self.model_name,
                contents=prompt,
            )
            
            text = response.text
            if "```json" in text:
                text = text.split("```json")[1].split("```")[0]
            elif "```" in text:
                text = text.split("```")[1].split("```")[0]
            
            data = json.loads(text.strip())
            
            logger.info("energy_production_analyzed",
                       status=data.get("status"),
                       efficiency=data.get("efficiency_percent"))
            
            return ProductionAnalysis(
                current_output_kw=float(data.get("current_output_kw", 0)),
                expected_output_kw=float(data.get("expected_output_kw", 0)),
                efficiency_percent=float(data.get("efficiency_percent", 0)),
                status=data.get("status", "unknown"),
                diagnosis=data.get("diagnosis", "No diagnosis"),
                recommendations=data.get("recommendations", []),
                estimated_daily_production_kwh=float(data.get("estimated_daily_production_kwh", 0)),
                carbon_offset_kg=float(data.get("carbon_offset_kg", 0)),
            )
            
        except Exception as e:
            logger.error("energy_analysis_error", error=str(e))
            return ProductionAnalysis(
                current_output_kw=readings.get("output_kw", 0),
                expected_output_kw=0,
                efficiency_percent=0,
                status="error",
                diagnosis=f"Analysis error: {str(e)}",
                recommendations=["Contact support"],
                estimated_daily_production_kwh=0,
                carbon_offset_kg=0,
            )

    async def generate_alerts(
        self,
        system_info: dict,
        current_state: dict,
    ) -> list[PerformanceAlert]:
        """
        Generate alerts based on current system state.
        
        Args:
            system_info: System specs
            current_state: Current readings and status
            
        Returns:
            List of alerts (may be empty)
        """
        if not self.client:
            return []
        
        prompt = self.ALERT_GENERATION_PROMPT.format(
            system_info=json.dumps(system_info, indent=2),
            current_state=json.dumps(current_state, indent=2),
        )
        
        try:
            response = await self.client.aio.models.generate_content(
                model=self.model_name,
                contents=prompt,
            )
            
            text = response.text
            if "```json" in text:
                text = text.split("```json")[1].split("```")[0]
            elif "```" in text:
                text = text.split("```")[1].split("```")[0]
            
            data = json.loads(text.strip())
            
            alerts = []
            for alert_data in data:
                alerts.append(PerformanceAlert(
                    severity=alert_data.get("severity", "info"),
                    alert_type=alert_data.get("alert_type", "general"),
                    message=alert_data.get("message", ""),
                    asset_id=system_info.get("id", "unknown"),
                    recommended_action=alert_data.get("recommended_action", ""),
                    estimated_revenue_impact=alert_data.get("estimated_revenue_impact"),
                ))
            
            logger.info("energy_alerts_generated", count=len(alerts))
            
            return alerts
            
        except Exception as e:
            logger.error("energy_alert_error", error=str(e))
            return []

    async def chat(
        self,
        message: str,
        context: dict = None,
        conversation_history: list = None,
    ) -> str:
        """Chat about energy assets using OSF Core."""
        return await self.core.chat(
            message=message,
            asset_class=AssetClass.ENERGY,
            context=context,
            conversation_history=conversation_history,
        )

    async def triage_issue(
        self,
        description: str,
        system_data: dict = None,
        images: list[bytes] = None,
    ):
        """Triage an energy system issue using OSF Core."""
        return await self.core.triage(
            description=description,
            asset_class=AssetClass.ENERGY,
            images=images,
            system_data=system_data,
        )
